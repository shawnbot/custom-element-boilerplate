{"version":3,"sources":["webpack:///custom-element.js","webpack:///webpack/bootstrap 48a797473a8b39eb3501","webpack:///./src/element.js","webpack:///./~/dom-delegate/lib/index.js","webpack:///./~/dom-delegate/lib/delegate.js","webpack:///./src/extend.js","webpack:///./src/privates.js","webpack:///./~/weakmap/weakmap.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Delegate","extend","privates","name","descriptors","foo","get","this","set","value","base","HTMLElement","proto","is","createdCallback","attachedCallback","delegate","on","onClick","attributeChangedCallback","previous","detachedCallback","off","document","registerElement","root","listenerMap","handle","prototype","bind","matchesTag","tagName","element","toLowerCase","matchesRoot","selector","rootElement","window","matchesId","eventType","hasOwnProperty","removeEventListener","addEventListener","captureForType","indexOf","handler","useCapture","matcher","matcherParam","TypeError","undefined","test","slice","matches","push","i","listener","listenerList","singleEventType","length","splice","event","l","phase","returned","target","type","EVENTIGNORE","nodeType","parentNode","eventPhase","currentTarget","concat","fire","preventDefault","parentElement","el","matchesSelector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","Element","destroy","createElement","constructor","Object","create","_get","has","obj","key","WeakMap","delete","global","undefined_","define","object","nameOf","replace","defProp","configurable","writable","func","toSource","match","funcName","createStorage","creator","storage","arguments","weakmap","WM","defaultCreator","getProps","getOwnPropertyNames","defineProperty","Function","toString","hasOwn","Data","puid","createUID","secret","unlock","store","data","dataDesc","datalock","uids","Math","random","globalID","isExtensible","props","o","v","iterable","wrap","initialize","validate","unwrap","delete_","had","collection","forEach","item","Array","src","del","e","split","stringifier","prep","__proto__","f","method","eval"],"mappings":"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","file":"custom-element.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Delegate = __webpack_require__(1).Delegate;\n\tvar extend = __webpack_require__(3);\n\tvar privates = __webpack_require__(4);\n\t\n\t// this is the name of your custom element\n\tvar name = 'custom-element';\n\t\n\tvar descriptors = {\n\t\n\t  /**\n\t   * Set the 'extends' descriptor to the name of an HTML element if you wish to\n\t   * use type extension. This will change the usage of your element from:\n\t   *\n\t   * <custom-element></custom-element>\n\t   *\n\t   * to:\n\t   *\n\t   * <base is=\"custom-element\"></base>\n\t   */\n\t  // 'extends': 'table',\n\t\n\t  foo: {\n\t    get: function() {\n\t      return privates.get(this, 'foo');\n\t    },\n\t    set: function(value) {\n\t      if (value !== this.foo) {\n\t        privates.set(this, 'foo', value);\n\t        // do something to update the DOM\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * You can also choose to extend a specific HTML element class here.\n\t *\n\t * NOTE: If you've set the 'extends' descriptor above, the base class is\n\t * determined dynamically, so this is ignored.\n\t */\n\tvar base = HTMLElement;\n\t\n\tvar proto = extend(base, is, descriptors);\n\t\n\tproto.createdCallback = function() {\n\t  // this function is called when your element is created,\n\t  // either via the constructor or document.createElement()\n\t};\n\t\n\t/**\n\t * This function is called when your element is attached to the document,\n\t * either directly or when one of its ancestors is appended.\n\t */\n\tproto.attachedCallback = function() {\n\t  var delegate = new Delegate(this);\n\t  delegate.on('click', 'button', onClick);\n\t  privates.set(this, 'delegate', delegate);\n\t};\n\t\n\t/**\n\t * This function is called whenever one of your element instance's attributes\n\t * is changed via `setAttribute()`.\n\t *\n\t * @param {String} name       the local attribute name (no namespace)\n\t * @param {String} previous   the previous attribute value, or `null`\n\t * @param {String} value      the new attribute value, or `null` if removed\n\t */\n\tproto.attributeChangedCallback = function(name, previous, value) {\n\t};\n\t\n\t/**\n\t * This is called when your element is detached from the document root,\n\t * either direct removal or removal of one of its ancestors.\n\t */\n\tproto.detachedCallback = function() {\n\t  var delegate = privates.get(this, 'delegate');\n\t  delegate.off();\n\t  privates.delete(this);\n\t};\n\t\n\tmodule.exports = document.registerElement(name, proto);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*jshint browser:true, node:true*/\n\t\n\t'use strict';\n\t\n\t/**\n\t * @preserve Create and manage a DOM event delegator.\n\t *\n\t * @version 0.3.0\n\t * @codingstandard ftlabs-jsv2\n\t * @copyright The Financial Times Limited [All Rights Reserved]\n\t * @license MIT License (see LICENSE.txt)\n\t */\n\tvar Delegate = __webpack_require__(2);\n\t\n\tmodule.exports = function(root) {\n\t  return new Delegate(root);\n\t};\n\t\n\tmodule.exports.Delegate = Delegate;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*jshint browser:true, node:true*/\n\t\n\t'use strict';\n\t\n\tmodule.exports = Delegate;\n\t\n\t/**\n\t * DOM event delegator\n\t *\n\t * The delegator will listen\n\t * for events that bubble up\n\t * to the root node.\n\t *\n\t * @constructor\n\t * @param {Node|string} [root] The root node or a selector string matching the root node\n\t */\n\tfunction Delegate(root) {\n\t\n\t  /**\n\t   * Maintain a map of listener\n\t   * lists, keyed by event name.\n\t   *\n\t   * @type Object\n\t   */\n\t  this.listenerMap = [{}, {}];\n\t  if (root) {\n\t    this.root(root);\n\t  }\n\t\n\t  /** @type function() */\n\t  this.handle = Delegate.prototype.handle.bind(this);\n\t}\n\t\n\t/**\n\t * Start listening for events\n\t * on the provided DOM element\n\t *\n\t * @param  {Node|string} [root] The root node or a selector string matching the root node\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.root = function(root) {\n\t  var listenerMap = this.listenerMap;\n\t  var eventType;\n\t\n\t  // Remove master event listeners\n\t  if (this.rootElement) {\n\t    for (eventType in listenerMap[1]) {\n\t      if (listenerMap[1].hasOwnProperty(eventType)) {\n\t        this.rootElement.removeEventListener(eventType, this.handle, true);\n\t      }\n\t    }\n\t    for (eventType in listenerMap[0]) {\n\t      if (listenerMap[0].hasOwnProperty(eventType)) {\n\t        this.rootElement.removeEventListener(eventType, this.handle, false);\n\t      }\n\t    }\n\t  }\n\t\n\t  // If no root or root is not\n\t  // a dom node, then remove internal\n\t  // root reference and exit here\n\t  if (!root || !root.addEventListener) {\n\t    if (this.rootElement) {\n\t      delete this.rootElement;\n\t    }\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * The root node at which\n\t   * listeners are attached.\n\t   *\n\t   * @type Node\n\t   */\n\t  this.rootElement = root;\n\t\n\t  // Set up master event listeners\n\t  for (eventType in listenerMap[1]) {\n\t    if (listenerMap[1].hasOwnProperty(eventType)) {\n\t      this.rootElement.addEventListener(eventType, this.handle, true);\n\t    }\n\t  }\n\t  for (eventType in listenerMap[0]) {\n\t    if (listenerMap[0].hasOwnProperty(eventType)) {\n\t      this.rootElement.addEventListener(eventType, this.handle, false);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} eventType\n\t * @returns boolean\n\t */\n\tDelegate.prototype.captureForType = function(eventType) {\n\t  return ['blur', 'error', 'focus', 'load', 'resize', 'scroll'].indexOf(eventType) !== -1;\n\t};\n\t\n\t/**\n\t * Attach a handler to one\n\t * event for all elements\n\t * that match the selector,\n\t * now or in the future\n\t *\n\t * The handler function receives\n\t * three arguments: the DOM event\n\t * object, the node that matched\n\t * the selector while the event\n\t * was bubbling and a reference\n\t * to itself. Within the handler,\n\t * 'this' is equal to the second\n\t * argument.\n\t *\n\t * The node that actually received\n\t * the event can be accessed via\n\t * 'event.target'.\n\t *\n\t * @param {string} eventType Listen for these events\n\t * @param {string|undefined} selector Only handle events on elements matching this selector, if undefined match root element\n\t * @param {function()} handler Handler function - event data passed here will be in event.data\n\t * @param {Object} [eventData] Data to pass in event.data\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.on = function(eventType, selector, handler, useCapture) {\n\t  var root, listenerMap, matcher, matcherParam;\n\t\n\t  if (!eventType) {\n\t    throw new TypeError('Invalid event type: ' + eventType);\n\t  }\n\t\n\t  // handler can be passed as\n\t  // the second or third argument\n\t  if (typeof selector === 'function') {\n\t    useCapture = handler;\n\t    handler = selector;\n\t    selector = null;\n\t  }\n\t\n\t  // Fallback to sensible defaults\n\t  // if useCapture not set\n\t  if (useCapture === undefined) {\n\t    useCapture = this.captureForType(eventType);\n\t  }\n\t\n\t  if (typeof handler !== 'function') {\n\t    throw new TypeError('Handler must be a type of Function');\n\t  }\n\t\n\t  root = this.rootElement;\n\t  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n\t\n\t  // Add master handler for type if not created yet\n\t  if (!listenerMap[eventType]) {\n\t    if (root) {\n\t      root.addEventListener(eventType, this.handle, useCapture);\n\t    }\n\t    listenerMap[eventType] = [];\n\t  }\n\t\n\t  if (!selector) {\n\t    matcherParam = null;\n\t\n\t    // COMPLEX - matchesRoot needs to have access to\n\t    // this.rootElement, so bind the function to this.\n\t    matcher = matchesRoot.bind(this);\n\t\n\t  // Compile a matcher for the given selector\n\t  } else if (/^[a-z]+$/i.test(selector)) {\n\t    matcherParam = selector;\n\t    matcher = matchesTag;\n\t  } else if (/^#[a-z0-9\\-_]+$/i.test(selector)) {\n\t    matcherParam = selector.slice(1);\n\t    matcher = matchesId;\n\t  } else {\n\t    matcherParam = selector;\n\t    matcher = matches;\n\t  }\n\t\n\t  // Add to the list of listeners\n\t  listenerMap[eventType].push({\n\t    selector: selector,\n\t    handler: handler,\n\t    matcher: matcher,\n\t    matcherParam: matcherParam\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove an event handler\n\t * for elements that match\n\t * the selector, forever\n\t *\n\t * @param {string} [eventType] Remove handlers for events matching this type, considering the other parameters\n\t * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed\n\t * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed\n\t * @returns {Delegate} This method is chainable\n\t */\n\tDelegate.prototype.off = function(eventType, selector, handler, useCapture) {\n\t  var i, listener, listenerMap, listenerList, singleEventType;\n\t\n\t  // Handler can be passed as\n\t  // the second or third argument\n\t  if (typeof selector === 'function') {\n\t    useCapture = handler;\n\t    handler = selector;\n\t    selector = null;\n\t  }\n\t\n\t  // If useCapture not set, remove\n\t  // all event listeners\n\t  if (useCapture === undefined) {\n\t    this.off(eventType, selector, handler, true);\n\t    this.off(eventType, selector, handler, false);\n\t    return this;\n\t  }\n\t\n\t  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n\t  if (!eventType) {\n\t    for (singleEventType in listenerMap) {\n\t      if (listenerMap.hasOwnProperty(singleEventType)) {\n\t        this.off(singleEventType, selector, handler);\n\t      }\n\t    }\n\t\n\t    return this;\n\t  }\n\t\n\t  listenerList = listenerMap[eventType];\n\t  if (!listenerList || !listenerList.length) {\n\t    return this;\n\t  }\n\t\n\t  // Remove only parameter matches\n\t  // if specified\n\t  for (i = listenerList.length - 1; i >= 0; i--) {\n\t    listener = listenerList[i];\n\t\n\t    if ((!selector || selector === listener.selector) && (!handler || handler === listener.handler)) {\n\t      listenerList.splice(i, 1);\n\t    }\n\t  }\n\t\n\t  // All listeners removed\n\t  if (!listenerList.length) {\n\t    delete listenerMap[eventType];\n\t\n\t    // Remove the main handler\n\t    if (this.rootElement) {\n\t      this.rootElement.removeEventListener(eventType, this.handle, useCapture);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Handle an arbitrary event.\n\t *\n\t * @param {Event} event\n\t */\n\tDelegate.prototype.handle = function(event) {\n\t  var i, l, type = event.type, root, phase, listener, returned, listenerList = [], target, /** @const */ EVENTIGNORE = 'ftLabsDelegateIgnore';\n\t\n\t  if (event[EVENTIGNORE] === true) {\n\t    return;\n\t  }\n\t\n\t  target = event.target;\n\t\n\t  // Hardcode value of Node.TEXT_NODE\n\t  // as not defined in IE8\n\t  if (target.nodeType === 3) {\n\t    target = target.parentNode;\n\t  }\n\t\n\t  root = this.rootElement;\n\t\n\t  phase = event.eventPhase || ( event.target !== event.currentTarget ? 3 : 2 );\n\t  \n\t  switch (phase) {\n\t    case 1: //Event.CAPTURING_PHASE:\n\t      listenerList = this.listenerMap[1][type];\n\t    break;\n\t    case 2: //Event.AT_TARGET:\n\t      if (this.listenerMap[0] && this.listenerMap[0][type]) listenerList = listenerList.concat(this.listenerMap[0][type]);\n\t      if (this.listenerMap[1] && this.listenerMap[1][type]) listenerList = listenerList.concat(this.listenerMap[1][type]);\n\t    break;\n\t    case 3: //Event.BUBBLING_PHASE:\n\t      listenerList = this.listenerMap[0][type];\n\t    break;\n\t  }\n\t\n\t  // Need to continuously check\n\t  // that the specific list is\n\t  // still populated in case one\n\t  // of the callbacks actually\n\t  // causes the list to be destroyed.\n\t  l = listenerList.length;\n\t  while (target && l) {\n\t    for (i = 0; i < l; i++) {\n\t      listener = listenerList[i];\n\t\n\t      // Bail from this loop if\n\t      // the length changed and\n\t      // no more listeners are\n\t      // defined between i and l.\n\t      if (!listener) {\n\t        break;\n\t      }\n\t\n\t      // Check for match and fire\n\t      // the event if there's one\n\t      //\n\t      // TODO:MCG:20120117: Need a way\n\t      // to check if event#stopImmediatePropagation\n\t      // was called. If so, break both loops.\n\t      if (listener.matcher.call(target, listener.matcherParam, target)) {\n\t        returned = this.fire(event, target, listener);\n\t      }\n\t\n\t      // Stop propagation to subsequent\n\t      // callbacks if the callback returned\n\t      // false\n\t      if (returned === false) {\n\t        event[EVENTIGNORE] = true;\n\t        event.preventDefault();\n\t        return;\n\t      }\n\t    }\n\t\n\t    // TODO:MCG:20120117: Need a way to\n\t    // check if event#stopPropagation\n\t    // was called. If so, break looping\n\t    // through the DOM. Stop if the\n\t    // delegation root has been reached\n\t    if (target === root) {\n\t      break;\n\t    }\n\t\n\t    l = listenerList.length;\n\t    target = target.parentElement;\n\t  }\n\t};\n\t\n\t/**\n\t * Fire a listener on a target.\n\t *\n\t * @param {Event} event\n\t * @param {Node} target\n\t * @param {Object} listener\n\t * @returns {boolean}\n\t */\n\tDelegate.prototype.fire = function(event, target, listener) {\n\t  return listener.handler.call(target, event, target);\n\t};\n\t\n\t/**\n\t * Check whether an element\n\t * matches a generic selector.\n\t *\n\t * @type function()\n\t * @param {string} selector A CSS selector\n\t */\n\tvar matches = (function(el) {\n\t  if (!el) return;\n\t  var p = el.prototype;\n\t  return (p.matches || p.matchesSelector || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector);\n\t}(Element));\n\t\n\t/**\n\t * Check whether an element\n\t * matches a tag selector.\n\t *\n\t * Tags are NOT case-sensitive,\n\t * except in XML (and XML-based\n\t * languages such as XHTML).\n\t *\n\t * @param {string} tagName The tag name to test against\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesTag(tagName, element) {\n\t  return tagName.toLowerCase() === element.tagName.toLowerCase();\n\t}\n\t\n\t/**\n\t * Check whether an element\n\t * matches the root.\n\t *\n\t * @param {?String} selector In this case this is always passed through as null and not used\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesRoot(selector, element) {\n\t  /*jshint validthis:true*/\n\t  if (this.rootElement === window) return element === document;\n\t  return this.rootElement === element;\n\t}\n\t\n\t/**\n\t * Check whether the ID of\n\t * the element in 'this'\n\t * matches the given ID.\n\t *\n\t * IDs are case-sensitive.\n\t *\n\t * @param {string} id The ID to test against\n\t * @param {Element} element The element to test with\n\t * @returns boolean\n\t */\n\tfunction matchesId(id, element) {\n\t  return id === element.id;\n\t}\n\t\n\t/**\n\t * Short hand for off()\n\t * and root(), ie both\n\t * with no parameters\n\t *\n\t * @return void\n\t */\n\tDelegate.prototype.destroy = function() {\n\t  this.off();\n\t  this.root();\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Create a new Element prototype that inherits from a named element (string)\n\t * or constructor reference.\n\t */\n\tmodule.exports = function(base, descriptors) {\n\t  var extend = descriptors['extends'];\n\t\n\t  if (typeof extend === 'string') {\n\t    base = document.createElement(base).constructor;\n\t  }\n\t\n\t  return Object.create(base.prototype, descriptors);\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar WeakMap = __webpack_require__(5);\n\tvar privates = new WeakMap();\n\t\n\tfunction _get(element) {\n\t  if (privates.has(element)) {\n\t    return privates.get(element);\n\t  }\n\t  var obj = {};\n\t  privates.set(element, obj);\n\t  return obj;\n\t}\n\t\n\tfunction get(element, key) {\n\t  return _get(element)[key];\n\t}\n\t\n\tfunction set(element, key, value) {\n\t  return _get(element)[key] = value;\n\t}\n\t\n\tmodule.exports = {\n\t  get: get,\n\t  set: set,\n\t  'delete': function(element) {\n\t    return privates.delete(element);\n\t  }\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* (The MIT License)\r\n\t *\r\n\t * Copyright (c) 2012 Brandon Benvie <http://bbenvie.com>\r\n\t *\r\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\r\n\t * associated documentation files (the 'Software'), to deal in the Software without restriction,\r\n\t * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n\t * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\r\n\t * furnished to do so, subject to the following conditions:\r\n\t *\r\n\t * The above copyright notice and this permission notice shall be included with all copies or\r\n\t * substantial portions of the Software.\r\n\t *\r\n\t * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n\t * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n\t * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM,\r\n\t * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n\t * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\t */\r\n\t\r\n\t// Original WeakMap implementation by Gozala @ https://gist.github.com/1269991\r\n\t// Updated and bugfixed by Raynos @ https://gist.github.com/1638059\r\n\t// Expanded by Benvie @ https://github.com/Benvie/harmony-collections\r\n\t\r\n\tvoid function(global, undefined_, undefined){\r\n\t  var getProps = Object.getOwnPropertyNames,\r\n\t      defProp  = Object.defineProperty,\r\n\t      toSource = Function.prototype.toString,\r\n\t      create   = Object.create,\r\n\t      hasOwn   = Object.prototype.hasOwnProperty,\r\n\t      funcName = /^\\n?function\\s?(\\w*)?_?\\(/;\r\n\t\r\n\t\r\n\t  function define(object, key, value){\r\n\t    if (typeof key === 'function') {\r\n\t      value = key;\r\n\t      key = nameOf(value).replace(/_$/, '');\r\n\t    }\r\n\t    return defProp(object, key, { configurable: true, writable: true, value: value });\r\n\t  }\r\n\t\r\n\t  function nameOf(func){\r\n\t    return typeof func !== 'function'\r\n\t          ? '' : 'name' in func\r\n\t          ? func.name : toSource.call(func).match(funcName)[1];\r\n\t  }\r\n\t\r\n\t  // ############\r\n\t  // ### Data ###\r\n\t  // ############\r\n\t\r\n\t  var Data = (function(){\r\n\t    var dataDesc = { value: { writable: true, value: undefined } },\r\n\t        datalock = 'return function(k){if(k===s)return l}',\r\n\t        uids     = create(null),\r\n\t\r\n\t        createUID = function(){\r\n\t          var key = Math.random().toString(36).slice(2);\r\n\t          return key in uids ? createUID() : uids[key] = key;\r\n\t        },\r\n\t\r\n\t        globalID = createUID(),\r\n\t\r\n\t        storage = function(obj){\r\n\t          if (hasOwn.call(obj, globalID))\r\n\t            return obj[globalID];\r\n\t\r\n\t          if (!Object.isExtensible(obj))\r\n\t            throw new TypeError(\"Object must be extensible\");\r\n\t\r\n\t          var store = create(null);\r\n\t          defProp(obj, globalID, { value: store });\r\n\t          return store;\r\n\t        };\r\n\t\r\n\t    // common per-object storage area made visible by patching getOwnPropertyNames'\r\n\t    define(Object, function getOwnPropertyNames(obj){\r\n\t      var props = getProps(obj);\r\n\t      if (hasOwn.call(obj, globalID))\r\n\t        props.splice(props.indexOf(globalID), 1);\r\n\t      return props;\r\n\t    });\r\n\t\r\n\t    function Data(){\r\n\t      var puid = createUID(),\r\n\t          secret = {};\r\n\t\r\n\t      this.unlock = function(obj){\r\n\t        var store = storage(obj);\r\n\t        if (hasOwn.call(store, puid))\r\n\t          return store[puid](secret);\r\n\t\r\n\t        var data = create(null, dataDesc);\r\n\t        defProp(store, puid, {\r\n\t          value: new Function('s', 'l', datalock)(secret, data)\r\n\t        });\r\n\t        return data;\r\n\t      }\r\n\t    }\r\n\t\r\n\t    define(Data.prototype, function get(o){ return this.unlock(o).value });\r\n\t    define(Data.prototype, function set(o, v){ this.unlock(o).value = v });\r\n\t\r\n\t    return Data;\r\n\t  }());\r\n\t\r\n\t\r\n\t  var WM = (function(data){\r\n\t    var validate = function(key){\r\n\t      if (key == null || typeof key !== 'object' && typeof key !== 'function')\r\n\t        throw new TypeError(\"Invalid WeakMap key\");\r\n\t    }\r\n\t\r\n\t    var wrap = function(collection, value){\r\n\t      var store = data.unlock(collection);\r\n\t      if (store.value)\r\n\t        throw new TypeError(\"Object is already a WeakMap\");\r\n\t      store.value = value;\r\n\t    }\r\n\t\r\n\t    var unwrap = function(collection){\r\n\t      var storage = data.unlock(collection).value;\r\n\t      if (!storage)\r\n\t        throw new TypeError(\"WeakMap is not generic\");\r\n\t      return storage;\r\n\t    }\r\n\t\r\n\t    var initialize = function(weakmap, iterable){\r\n\t      if (iterable !== null && typeof iterable === 'object' && typeof iterable.forEach === 'function') {\r\n\t        iterable.forEach(function(item, i){\r\n\t          if (item instanceof Array && item.length === 2)\r\n\t            set.call(weakmap, iterable[i][0], iterable[i][1]);\r\n\t        });\r\n\t      }\r\n\t    }\r\n\t\r\n\t\r\n\t    function WeakMap(iterable){\r\n\t      if (this === global || this == null || this === WeakMap.prototype)\r\n\t        return new WeakMap(iterable);\r\n\t\r\n\t      wrap(this, new Data);\r\n\t      initialize(this, iterable);\r\n\t    }\r\n\t\r\n\t    function get(key){\r\n\t      validate(key);\r\n\t      var value = unwrap(this).get(key);\r\n\t      return value === undefined_ ? undefined : value;\r\n\t    }\r\n\t\r\n\t    function set(key, value){\r\n\t      validate(key);\r\n\t      // store a token for explicit undefined so that \"has\" works correctly\r\n\t      unwrap(this).set(key, value === undefined ? undefined_ : value);\r\n\t    }\r\n\t\r\n\t    function has(key){\r\n\t      validate(key);\r\n\t      return unwrap(this).get(key) !== undefined;\r\n\t    }\r\n\t\r\n\t    function delete_(key){\r\n\t      validate(key);\r\n\t      var data = unwrap(this),\r\n\t          had = data.get(key) !== undefined;\r\n\t      data.set(key, undefined);\r\n\t      return had;\r\n\t    }\r\n\t\r\n\t    function toString(){\r\n\t      unwrap(this);\r\n\t      return '[object WeakMap]';\r\n\t    }\r\n\t\r\n\t    try {\r\n\t      var src = ('return '+delete_).replace('e_', '\\\\u0065'),\r\n\t          del = new Function('unwrap', 'validate', src)(unwrap, validate);\r\n\t    } catch (e) {\r\n\t      var del = delete_;\r\n\t    }\r\n\t\r\n\t    var src = (''+Object).split('Object');\r\n\t    var stringifier = function toString(){\r\n\t      return src[0] + nameOf(this) + src[1];\r\n\t    };\r\n\t\r\n\t    define(stringifier, stringifier);\r\n\t\r\n\t    var prep = { __proto__: [] } instanceof Array\r\n\t      ? function(f){ f.__proto__ = stringifier }\r\n\t      : function(f){ define(f, stringifier) };\r\n\t\r\n\t    prep(WeakMap);\r\n\t\r\n\t    [toString, get, set, has, del].forEach(function(method){\r\n\t      define(WeakMap.prototype, method);\r\n\t      prep(method);\r\n\t    });\r\n\t\r\n\t    return WeakMap;\r\n\t  }(new Data));\r\n\t\r\n\t  var defaultCreator = Object.create\r\n\t    ? function(){ return Object.create(null) }\r\n\t    : function(){ return {} };\r\n\t\r\n\t  function createStorage(creator){\r\n\t    var weakmap = new WM;\r\n\t    creator || (creator = defaultCreator);\r\n\t\r\n\t    function storage(object, value){\r\n\t      if (value || arguments.length === 2) {\r\n\t        weakmap.set(object, value);\r\n\t      } else {\r\n\t        value = weakmap.get(object);\r\n\t        if (value === undefined) {\r\n\t          value = creator(object);\r\n\t          weakmap.set(object, value);\r\n\t        }\r\n\t      }\r\n\t      return value;\r\n\t    }\r\n\t\r\n\t    return storage;\r\n\t  }\r\n\t\r\n\t\r\n\t  if (true) {\r\n\t    module.exports = WM;\r\n\t  } else if (typeof exports !== 'undefined') {\r\n\t    exports.WeakMap = WM;\r\n\t  } else if (!('WeakMap' in global)) {\r\n\t    global.WeakMap = WM;\r\n\t  }\r\n\t\r\n\t  WM.createStorage = createStorage;\r\n\t  if (global.WeakMap)\r\n\t    global.WeakMap.createStorage = createStorage;\r\n\t}((0, eval)('this'));\r\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** custom-element.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 48a797473a8b39eb3501\n **/","var Delegate = require('dom-delegate').Delegate;\nvar extend = require('./extend');\nvar privates = require('./privates');\n\n// this is the name of your custom element\nvar name = 'custom-element';\n\nvar descriptors = {\n\n  /**\n   * Set the 'extends' descriptor to the name of an HTML element if you wish to\n   * use type extension. This will change the usage of your element from:\n   *\n   * <custom-element></custom-element>\n   *\n   * to:\n   *\n   * <base is=\"custom-element\"></base>\n   */\n  // 'extends': 'table',\n\n  foo: {\n    get: function() {\n      return privates.get(this, 'foo');\n    },\n    set: function(value) {\n      if (value !== this.foo) {\n        privates.set(this, 'foo', value);\n        // do something to update the DOM\n      }\n    }\n  }\n};\n\n/**\n * You can also choose to extend a specific HTML element class here.\n *\n * NOTE: If you've set the 'extends' descriptor above, the base class is\n * determined dynamically, so this is ignored.\n */\nvar base = HTMLElement;\n\nvar proto = extend(base, is, descriptors);\n\nproto.createdCallback = function() {\n  // this function is called when your element is created,\n  // either via the constructor or document.createElement()\n};\n\n/**\n * This function is called when your element is attached to the document,\n * either directly or when one of its ancestors is appended.\n */\nproto.attachedCallback = function() {\n  var delegate = new Delegate(this);\n  delegate.on('click', 'button', onClick);\n  privates.set(this, 'delegate', delegate);\n};\n\n/**\n * This function is called whenever one of your element instance's attributes\n * is changed via `setAttribute()`.\n *\n * @param {String} name       the local attribute name (no namespace)\n * @param {String} previous   the previous attribute value, or `null`\n * @param {String} value      the new attribute value, or `null` if removed\n */\nproto.attributeChangedCallback = function(name, previous, value) {\n};\n\n/**\n * This is called when your element is detached from the document root,\n * either direct removal or removal of one of its ancestors.\n */\nproto.detachedCallback = function() {\n  var delegate = privates.get(this, 'delegate');\n  delegate.off();\n  privates.delete(this);\n};\n\nmodule.exports = document.registerElement(name, proto);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/element.js\n ** module id = 0\n ** module chunks = 0\n **/","/*jshint browser:true, node:true*/\n\n'use strict';\n\n/**\n * @preserve Create and manage a DOM event delegator.\n *\n * @version 0.3.0\n * @codingstandard ftlabs-jsv2\n * @copyright The Financial Times Limited [All Rights Reserved]\n * @license MIT License (see LICENSE.txt)\n */\nvar Delegate = require('./delegate');\n\nmodule.exports = function(root) {\n  return new Delegate(root);\n};\n\nmodule.exports.Delegate = Delegate;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/dom-delegate/lib/index.js\n ** module id = 1\n ** module chunks = 0\n **/","/*jshint browser:true, node:true*/\n\n'use strict';\n\nmodule.exports = Delegate;\n\n/**\n * DOM event delegator\n *\n * The delegator will listen\n * for events that bubble up\n * to the root node.\n *\n * @constructor\n * @param {Node|string} [root] The root node or a selector string matching the root node\n */\nfunction Delegate(root) {\n\n  /**\n   * Maintain a map of listener\n   * lists, keyed by event name.\n   *\n   * @type Object\n   */\n  this.listenerMap = [{}, {}];\n  if (root) {\n    this.root(root);\n  }\n\n  /** @type function() */\n  this.handle = Delegate.prototype.handle.bind(this);\n}\n\n/**\n * Start listening for events\n * on the provided DOM element\n *\n * @param  {Node|string} [root] The root node or a selector string matching the root node\n * @returns {Delegate} This method is chainable\n */\nDelegate.prototype.root = function(root) {\n  var listenerMap = this.listenerMap;\n  var eventType;\n\n  // Remove master event listeners\n  if (this.rootElement) {\n    for (eventType in listenerMap[1]) {\n      if (listenerMap[1].hasOwnProperty(eventType)) {\n        this.rootElement.removeEventListener(eventType, this.handle, true);\n      }\n    }\n    for (eventType in listenerMap[0]) {\n      if (listenerMap[0].hasOwnProperty(eventType)) {\n        this.rootElement.removeEventListener(eventType, this.handle, false);\n      }\n    }\n  }\n\n  // If no root or root is not\n  // a dom node, then remove internal\n  // root reference and exit here\n  if (!root || !root.addEventListener) {\n    if (this.rootElement) {\n      delete this.rootElement;\n    }\n    return this;\n  }\n\n  /**\n   * The root node at which\n   * listeners are attached.\n   *\n   * @type Node\n   */\n  this.rootElement = root;\n\n  // Set up master event listeners\n  for (eventType in listenerMap[1]) {\n    if (listenerMap[1].hasOwnProperty(eventType)) {\n      this.rootElement.addEventListener(eventType, this.handle, true);\n    }\n  }\n  for (eventType in listenerMap[0]) {\n    if (listenerMap[0].hasOwnProperty(eventType)) {\n      this.rootElement.addEventListener(eventType, this.handle, false);\n    }\n  }\n\n  return this;\n};\n\n/**\n * @param {string} eventType\n * @returns boolean\n */\nDelegate.prototype.captureForType = function(eventType) {\n  return ['blur', 'error', 'focus', 'load', 'resize', 'scroll'].indexOf(eventType) !== -1;\n};\n\n/**\n * Attach a handler to one\n * event for all elements\n * that match the selector,\n * now or in the future\n *\n * The handler function receives\n * three arguments: the DOM event\n * object, the node that matched\n * the selector while the event\n * was bubbling and a reference\n * to itself. Within the handler,\n * 'this' is equal to the second\n * argument.\n *\n * The node that actually received\n * the event can be accessed via\n * 'event.target'.\n *\n * @param {string} eventType Listen for these events\n * @param {string|undefined} selector Only handle events on elements matching this selector, if undefined match root element\n * @param {function()} handler Handler function - event data passed here will be in event.data\n * @param {Object} [eventData] Data to pass in event.data\n * @returns {Delegate} This method is chainable\n */\nDelegate.prototype.on = function(eventType, selector, handler, useCapture) {\n  var root, listenerMap, matcher, matcherParam;\n\n  if (!eventType) {\n    throw new TypeError('Invalid event type: ' + eventType);\n  }\n\n  // handler can be passed as\n  // the second or third argument\n  if (typeof selector === 'function') {\n    useCapture = handler;\n    handler = selector;\n    selector = null;\n  }\n\n  // Fallback to sensible defaults\n  // if useCapture not set\n  if (useCapture === undefined) {\n    useCapture = this.captureForType(eventType);\n  }\n\n  if (typeof handler !== 'function') {\n    throw new TypeError('Handler must be a type of Function');\n  }\n\n  root = this.rootElement;\n  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n\n  // Add master handler for type if not created yet\n  if (!listenerMap[eventType]) {\n    if (root) {\n      root.addEventListener(eventType, this.handle, useCapture);\n    }\n    listenerMap[eventType] = [];\n  }\n\n  if (!selector) {\n    matcherParam = null;\n\n    // COMPLEX - matchesRoot needs to have access to\n    // this.rootElement, so bind the function to this.\n    matcher = matchesRoot.bind(this);\n\n  // Compile a matcher for the given selector\n  } else if (/^[a-z]+$/i.test(selector)) {\n    matcherParam = selector;\n    matcher = matchesTag;\n  } else if (/^#[a-z0-9\\-_]+$/i.test(selector)) {\n    matcherParam = selector.slice(1);\n    matcher = matchesId;\n  } else {\n    matcherParam = selector;\n    matcher = matches;\n  }\n\n  // Add to the list of listeners\n  listenerMap[eventType].push({\n    selector: selector,\n    handler: handler,\n    matcher: matcher,\n    matcherParam: matcherParam\n  });\n\n  return this;\n};\n\n/**\n * Remove an event handler\n * for elements that match\n * the selector, forever\n *\n * @param {string} [eventType] Remove handlers for events matching this type, considering the other parameters\n * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed\n * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed\n * @returns {Delegate} This method is chainable\n */\nDelegate.prototype.off = function(eventType, selector, handler, useCapture) {\n  var i, listener, listenerMap, listenerList, singleEventType;\n\n  // Handler can be passed as\n  // the second or third argument\n  if (typeof selector === 'function') {\n    useCapture = handler;\n    handler = selector;\n    selector = null;\n  }\n\n  // If useCapture not set, remove\n  // all event listeners\n  if (useCapture === undefined) {\n    this.off(eventType, selector, handler, true);\n    this.off(eventType, selector, handler, false);\n    return this;\n  }\n\n  listenerMap = this.listenerMap[useCapture ? 1 : 0];\n  if (!eventType) {\n    for (singleEventType in listenerMap) {\n      if (listenerMap.hasOwnProperty(singleEventType)) {\n        this.off(singleEventType, selector, handler);\n      }\n    }\n\n    return this;\n  }\n\n  listenerList = listenerMap[eventType];\n  if (!listenerList || !listenerList.length) {\n    return this;\n  }\n\n  // Remove only parameter matches\n  // if specified\n  for (i = listenerList.length - 1; i >= 0; i--) {\n    listener = listenerList[i];\n\n    if ((!selector || selector === listener.selector) && (!handler || handler === listener.handler)) {\n      listenerList.splice(i, 1);\n    }\n  }\n\n  // All listeners removed\n  if (!listenerList.length) {\n    delete listenerMap[eventType];\n\n    // Remove the main handler\n    if (this.rootElement) {\n      this.rootElement.removeEventListener(eventType, this.handle, useCapture);\n    }\n  }\n\n  return this;\n};\n\n\n/**\n * Handle an arbitrary event.\n *\n * @param {Event} event\n */\nDelegate.prototype.handle = function(event) {\n  var i, l, type = event.type, root, phase, listener, returned, listenerList = [], target, /** @const */ EVENTIGNORE = 'ftLabsDelegateIgnore';\n\n  if (event[EVENTIGNORE] === true) {\n    return;\n  }\n\n  target = event.target;\n\n  // Hardcode value of Node.TEXT_NODE\n  // as not defined in IE8\n  if (target.nodeType === 3) {\n    target = target.parentNode;\n  }\n\n  root = this.rootElement;\n\n  phase = event.eventPhase || ( event.target !== event.currentTarget ? 3 : 2 );\n  \n  switch (phase) {\n    case 1: //Event.CAPTURING_PHASE:\n      listenerList = this.listenerMap[1][type];\n    break;\n    case 2: //Event.AT_TARGET:\n      if (this.listenerMap[0] && this.listenerMap[0][type]) listenerList = listenerList.concat(this.listenerMap[0][type]);\n      if (this.listenerMap[1] && this.listenerMap[1][type]) listenerList = listenerList.concat(this.listenerMap[1][type]);\n    break;\n    case 3: //Event.BUBBLING_PHASE:\n      listenerList = this.listenerMap[0][type];\n    break;\n  }\n\n  // Need to continuously check\n  // that the specific list is\n  // still populated in case one\n  // of the callbacks actually\n  // causes the list to be destroyed.\n  l = listenerList.length;\n  while (target && l) {\n    for (i = 0; i < l; i++) {\n      listener = listenerList[i];\n\n      // Bail from this loop if\n      // the length changed and\n      // no more listeners are\n      // defined between i and l.\n      if (!listener) {\n        break;\n      }\n\n      // Check for match and fire\n      // the event if there's one\n      //\n      // TODO:MCG:20120117: Need a way\n      // to check if event#stopImmediatePropagation\n      // was called. If so, break both loops.\n      if (listener.matcher.call(target, listener.matcherParam, target)) {\n        returned = this.fire(event, target, listener);\n      }\n\n      // Stop propagation to subsequent\n      // callbacks if the callback returned\n      // false\n      if (returned === false) {\n        event[EVENTIGNORE] = true;\n        event.preventDefault();\n        return;\n      }\n    }\n\n    // TODO:MCG:20120117: Need a way to\n    // check if event#stopPropagation\n    // was called. If so, break looping\n    // through the DOM. Stop if the\n    // delegation root has been reached\n    if (target === root) {\n      break;\n    }\n\n    l = listenerList.length;\n    target = target.parentElement;\n  }\n};\n\n/**\n * Fire a listener on a target.\n *\n * @param {Event} event\n * @param {Node} target\n * @param {Object} listener\n * @returns {boolean}\n */\nDelegate.prototype.fire = function(event, target, listener) {\n  return listener.handler.call(target, event, target);\n};\n\n/**\n * Check whether an element\n * matches a generic selector.\n *\n * @type function()\n * @param {string} selector A CSS selector\n */\nvar matches = (function(el) {\n  if (!el) return;\n  var p = el.prototype;\n  return (p.matches || p.matchesSelector || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector);\n}(Element));\n\n/**\n * Check whether an element\n * matches a tag selector.\n *\n * Tags are NOT case-sensitive,\n * except in XML (and XML-based\n * languages such as XHTML).\n *\n * @param {string} tagName The tag name to test against\n * @param {Element} element The element to test with\n * @returns boolean\n */\nfunction matchesTag(tagName, element) {\n  return tagName.toLowerCase() === element.tagName.toLowerCase();\n}\n\n/**\n * Check whether an element\n * matches the root.\n *\n * @param {?String} selector In this case this is always passed through as null and not used\n * @param {Element} element The element to test with\n * @returns boolean\n */\nfunction matchesRoot(selector, element) {\n  /*jshint validthis:true*/\n  if (this.rootElement === window) return element === document;\n  return this.rootElement === element;\n}\n\n/**\n * Check whether the ID of\n * the element in 'this'\n * matches the given ID.\n *\n * IDs are case-sensitive.\n *\n * @param {string} id The ID to test against\n * @param {Element} element The element to test with\n * @returns boolean\n */\nfunction matchesId(id, element) {\n  return id === element.id;\n}\n\n/**\n * Short hand for off()\n * and root(), ie both\n * with no parameters\n *\n * @return void\n */\nDelegate.prototype.destroy = function() {\n  this.off();\n  this.root();\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/dom-delegate/lib/delegate.js\n ** module id = 2\n ** module chunks = 0\n **/","/**\n * Create a new Element prototype that inherits from a named element (string)\n * or constructor reference.\n */\nmodule.exports = function(base, descriptors) {\n  var extend = descriptors['extends'];\n\n  if (typeof extend === 'string') {\n    base = document.createElement(base).constructor;\n  }\n\n  return Object.create(base.prototype, descriptors);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/extend.js\n ** module id = 3\n ** module chunks = 0\n **/","var WeakMap = require('weakmap');\nvar privates = new WeakMap();\n\nfunction _get(element) {\n  if (privates.has(element)) {\n    return privates.get(element);\n  }\n  var obj = {};\n  privates.set(element, obj);\n  return obj;\n}\n\nfunction get(element, key) {\n  return _get(element)[key];\n}\n\nfunction set(element, key, value) {\n  return _get(element)[key] = value;\n}\n\nmodule.exports = {\n  get: get,\n  set: set,\n  'delete': function(element) {\n    return privates.delete(element);\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/privates.js\n ** module id = 4\n ** module chunks = 0\n **/","/* (The MIT License)\r\n *\r\n * Copyright (c) 2012 Brandon Benvie <http://bbenvie.com>\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\r\n * associated documentation files (the 'Software'), to deal in the Software without restriction,\r\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included with all copies or\r\n * substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n// Original WeakMap implementation by Gozala @ https://gist.github.com/1269991\r\n// Updated and bugfixed by Raynos @ https://gist.github.com/1638059\r\n// Expanded by Benvie @ https://github.com/Benvie/harmony-collections\r\n\r\nvoid function(global, undefined_, undefined){\r\n  var getProps = Object.getOwnPropertyNames,\r\n      defProp  = Object.defineProperty,\r\n      toSource = Function.prototype.toString,\r\n      create   = Object.create,\r\n      hasOwn   = Object.prototype.hasOwnProperty,\r\n      funcName = /^\\n?function\\s?(\\w*)?_?\\(/;\r\n\r\n\r\n  function define(object, key, value){\r\n    if (typeof key === 'function') {\r\n      value = key;\r\n      key = nameOf(value).replace(/_$/, '');\r\n    }\r\n    return defProp(object, key, { configurable: true, writable: true, value: value });\r\n  }\r\n\r\n  function nameOf(func){\r\n    return typeof func !== 'function'\r\n          ? '' : 'name' in func\r\n          ? func.name : toSource.call(func).match(funcName)[1];\r\n  }\r\n\r\n  // ############\r\n  // ### Data ###\r\n  // ############\r\n\r\n  var Data = (function(){\r\n    var dataDesc = { value: { writable: true, value: undefined } },\r\n        datalock = 'return function(k){if(k===s)return l}',\r\n        uids     = create(null),\r\n\r\n        createUID = function(){\r\n          var key = Math.random().toString(36).slice(2);\r\n          return key in uids ? createUID() : uids[key] = key;\r\n        },\r\n\r\n        globalID = createUID(),\r\n\r\n        storage = function(obj){\r\n          if (hasOwn.call(obj, globalID))\r\n            return obj[globalID];\r\n\r\n          if (!Object.isExtensible(obj))\r\n            throw new TypeError(\"Object must be extensible\");\r\n\r\n          var store = create(null);\r\n          defProp(obj, globalID, { value: store });\r\n          return store;\r\n        };\r\n\r\n    // common per-object storage area made visible by patching getOwnPropertyNames'\r\n    define(Object, function getOwnPropertyNames(obj){\r\n      var props = getProps(obj);\r\n      if (hasOwn.call(obj, globalID))\r\n        props.splice(props.indexOf(globalID), 1);\r\n      return props;\r\n    });\r\n\r\n    function Data(){\r\n      var puid = createUID(),\r\n          secret = {};\r\n\r\n      this.unlock = function(obj){\r\n        var store = storage(obj);\r\n        if (hasOwn.call(store, puid))\r\n          return store[puid](secret);\r\n\r\n        var data = create(null, dataDesc);\r\n        defProp(store, puid, {\r\n          value: new Function('s', 'l', datalock)(secret, data)\r\n        });\r\n        return data;\r\n      }\r\n    }\r\n\r\n    define(Data.prototype, function get(o){ return this.unlock(o).value });\r\n    define(Data.prototype, function set(o, v){ this.unlock(o).value = v });\r\n\r\n    return Data;\r\n  }());\r\n\r\n\r\n  var WM = (function(data){\r\n    var validate = function(key){\r\n      if (key == null || typeof key !== 'object' && typeof key !== 'function')\r\n        throw new TypeError(\"Invalid WeakMap key\");\r\n    }\r\n\r\n    var wrap = function(collection, value){\r\n      var store = data.unlock(collection);\r\n      if (store.value)\r\n        throw new TypeError(\"Object is already a WeakMap\");\r\n      store.value = value;\r\n    }\r\n\r\n    var unwrap = function(collection){\r\n      var storage = data.unlock(collection).value;\r\n      if (!storage)\r\n        throw new TypeError(\"WeakMap is not generic\");\r\n      return storage;\r\n    }\r\n\r\n    var initialize = function(weakmap, iterable){\r\n      if (iterable !== null && typeof iterable === 'object' && typeof iterable.forEach === 'function') {\r\n        iterable.forEach(function(item, i){\r\n          if (item instanceof Array && item.length === 2)\r\n            set.call(weakmap, iterable[i][0], iterable[i][1]);\r\n        });\r\n      }\r\n    }\r\n\r\n\r\n    function WeakMap(iterable){\r\n      if (this === global || this == null || this === WeakMap.prototype)\r\n        return new WeakMap(iterable);\r\n\r\n      wrap(this, new Data);\r\n      initialize(this, iterable);\r\n    }\r\n\r\n    function get(key){\r\n      validate(key);\r\n      var value = unwrap(this).get(key);\r\n      return value === undefined_ ? undefined : value;\r\n    }\r\n\r\n    function set(key, value){\r\n      validate(key);\r\n      // store a token for explicit undefined so that \"has\" works correctly\r\n      unwrap(this).set(key, value === undefined ? undefined_ : value);\r\n    }\r\n\r\n    function has(key){\r\n      validate(key);\r\n      return unwrap(this).get(key) !== undefined;\r\n    }\r\n\r\n    function delete_(key){\r\n      validate(key);\r\n      var data = unwrap(this),\r\n          had = data.get(key) !== undefined;\r\n      data.set(key, undefined);\r\n      return had;\r\n    }\r\n\r\n    function toString(){\r\n      unwrap(this);\r\n      return '[object WeakMap]';\r\n    }\r\n\r\n    try {\r\n      var src = ('return '+delete_).replace('e_', '\\\\u0065'),\r\n          del = new Function('unwrap', 'validate', src)(unwrap, validate);\r\n    } catch (e) {\r\n      var del = delete_;\r\n    }\r\n\r\n    var src = (''+Object).split('Object');\r\n    var stringifier = function toString(){\r\n      return src[0] + nameOf(this) + src[1];\r\n    };\r\n\r\n    define(stringifier, stringifier);\r\n\r\n    var prep = { __proto__: [] } instanceof Array\r\n      ? function(f){ f.__proto__ = stringifier }\r\n      : function(f){ define(f, stringifier) };\r\n\r\n    prep(WeakMap);\r\n\r\n    [toString, get, set, has, del].forEach(function(method){\r\n      define(WeakMap.prototype, method);\r\n      prep(method);\r\n    });\r\n\r\n    return WeakMap;\r\n  }(new Data));\r\n\r\n  var defaultCreator = Object.create\r\n    ? function(){ return Object.create(null) }\r\n    : function(){ return {} };\r\n\r\n  function createStorage(creator){\r\n    var weakmap = new WM;\r\n    creator || (creator = defaultCreator);\r\n\r\n    function storage(object, value){\r\n      if (value || arguments.length === 2) {\r\n        weakmap.set(object, value);\r\n      } else {\r\n        value = weakmap.get(object);\r\n        if (value === undefined) {\r\n          value = creator(object);\r\n          weakmap.set(object, value);\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n\r\n    return storage;\r\n  }\r\n\r\n\r\n  if (typeof module !== 'undefined') {\r\n    module.exports = WM;\r\n  } else if (typeof exports !== 'undefined') {\r\n    exports.WeakMap = WM;\r\n  } else if (!('WeakMap' in global)) {\r\n    global.WeakMap = WM;\r\n  }\r\n\r\n  WM.createStorage = createStorage;\r\n  if (global.WeakMap)\r\n    global.WeakMap.createStorage = createStorage;\r\n}((0, eval)('this'));\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/weakmap/weakmap.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}